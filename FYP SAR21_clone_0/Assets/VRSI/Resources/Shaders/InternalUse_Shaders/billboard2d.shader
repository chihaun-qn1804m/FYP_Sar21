// Upgrade NOTE: replaced '_World2Object' with 'unity_WorldToObject'
// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)'

Shader "Hidden/billboard2d"
{
	Properties
	{
		_MainTex("Texture Image", 2D) = "white" {}
		_Color1("Color1", COLOR) = (1,1,1,1)
	}

	SubShader
	{
		AlphaTest Greater[_Cutoff]
		

		Tags {"Queue" = "Transparent" "RenderType" = "Transparent"}
	 LOD 100
	 Blend SrcAlpha OneMinusSrcAlpha
		
		ZWrite On
		
		Cull Off
		

	Pass
	{	
		
	CGPROGRAM
	#pragma vertex vert  
	#pragma fragment frag
	       
	uniform sampler2D _MainTex;
	float4 _Color1;	

	struct vertexInput
	{
		float4 vertex : POSITION;
		float4 tex : TEXCOORD0;
	};
	struct vertexOutput
	{
		float4 pos : SV_POSITION;
		float4 tex : TEXCOORD0;		
	};

	inline float3x3 look_matrix33(float3 dir, float3 up)
	{
		float3 z = dir;
		float3 x = normalize(cross(up, z));
		float3 y = cross(z, x);
		return float3x3(
			x.x, y.x, z.x,
			x.y, y.y, z.y,
			x.z, y.z, z.z);
	}

	vertexOutput vert(vertexInput input)
	{
		vertexOutput output;
		
		float3 look = normalize(mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, 1.0))); //campos;// normalize(campos.xyz - origin);

		look.y = 0;
		
		const float3 local = float3(input.vertex.x, input.vertex.y, 0); // this is the quad verts as generated by MakeMesh.cs in the localPos list.
		const float3 offset = input.vertex.xyz - local;
				
		const float3 upVector = half3(0, 1, 0);
		const float3 forwardVector = -look;// UNITY_MATRIX_IT_MV[2].xyz; // camera forward
		const float3 rightVector = normalize(cross(forwardVector, upVector));

		float3 position = 0;
		position += local.x * rightVector;
		position += local.y * upVector;
		position += local.z * forwardVector;

		input.vertex = float4(offset + position, 1);


		output.pos = UnityObjectToClipPos(input.vertex);

		output.tex = input.tex;
		

		return output;
		
	}

	float4 frag(vertexOutput input) : COLOR
	{
		float2 uv = input.tex.xy;

		//uv.x = 0.5*input.stIndex + input.tex.x * 0.5;

		float4 col = _Color1*tex2D(_MainTex, uv);

		//col.rgb *= input.col.rgb;

		//float2 uv2 = input.tex.xy;
		//uv2.x = input.tex.x * 0.5;
		//float4 col2 = tex2D(_MainTex, uv2);
		//col.rgb = lerp(col, col2, input.camdist);

		//clip(col.a - 0.5);
		return col;
	}

		ENDCG
	}
	}
}